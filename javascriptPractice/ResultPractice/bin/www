#!/usr/bin/env node

/**
 * Module dependencies.
 */
var app = require('../app');
var debug = require('debug')('resultpractice:server');
var http = require('http');
const io = require("socket.io")(http);//匯入socket.io


/**
 * Save information from Client side.
 */

class saveClient {}//www端接收模板

class saveServer{//www端儲存庫模板
  constructor() {
    this.IP = [];//IP庫,不可覆寫
    this.Join = 0;//體驗者人數
    this.Sup = 0;//協助者人數
    this.rolelocks = [];//角色庫，不可覆寫
    this.users =[];//角色名稱庫
    this.JoinUserBirth = 0;//生日
    this.GameLock = false;
    // this.joinlock = [];//鎖頭庫,不可覆寫
  }
}
class ServerQuest{//伺服端問題庫
  constructor() {
    this.questRole = null;//角色種類名稱
    this.questRoleIndex = [];//題庫種類，基本上userRole是它的索引值，主要用於意外處理
    this.questIndex =[];//題庫索引，第幾題的意思
    this.questBase =[];//題庫
  }
}
let setQuestBase = new ServerQuest();//題庫實例化
///////////////////////////////////////////////////伺服端連線/資料交換///////////////////////////
let serverClient = new saveClient();//建立www端物件來儲存接收資訊，可覆寫
let RestartBase = new saveClient();//初始化www端資料庫
let saveBase= new saveServer();//www端儲存最新版
let IPIndex = 0;
let catchIndex = 0;
////////////////////////////////////////////////確認連線、IP獲取/////////////////////////////////
/**
 * socket.io Listen 
 */
io.on("connection",function (socket) {
  ////////////////抓本機虛擬IP///////////////////////////////////
////////////失敗/////////////////////////
  //建立client端監測接收端，如監測到connection類型被client端丟出，則印出丟出的client IP
  /////////////////////////////////////////////初始化///////////////////////////////////////////
  let ClientIP = socket.handshake.address;//取得要求連線之IP位置

  if(saveBase.IP.find(checkIP)===undefined)//如果IP庫不存在此IP，則存入IP庫
  {
    saveBase.IP[IPIndex] = ClientIP;
    catchIndex = IPIndex;//此Client端的IP位置視為存取位置
    // saveBase.rolelocks[catchIndex] = undefined;
    IPIndex+=1;
    console.log("New Connect Success! New ClientIP: "+ClientIP);
  }
  else//如果IP存在則視為此Client端為重新連線
  {
    catchIndex = saveBase.IP.indexOf(ClientIP);//此Client端的取物索引
  }
  socket.emit("Set",ClientIP,saveBase,catchIndex);//將IP、www端資料傳給Client端
  // console.log("set: "+catchIndex)

  function checkIP(element)
  {
    return  element === ClientIP;
  }

  /////////////////////////////////////////Data新增對比更新/////////////////////////////////////////
    socket.on("ClientUpData",function (ClientUpData) {//接收Client端Data更新

      serverClient = ClientUpData;//將接收的物件用www端物件存取

  ///////////////////////////////////////////更新www端更新///////////////////////////////////
      saveBase.Join = serverClient.Join;//更新www端Join值
      saveBase.Sup = serverClient.Sup;//更新www端Sup值
      
      catchIndex = saveBase.IP.indexOf(ClientIP);//取的此Client IP位於伺服端的儲存索引
      saveBase.rolelocks[catchIndex] = serverClient.rolelock;//更新角色種類
      saveBase.users[catchIndex] = serverClient.user;//更新角色名稱
      saveBase.GameLock = serverClient.GameLock;

      if(serverClient.rolelock ===1)
      {
        saveBase.JoinUserBirth = serverClient.JoinBirth;//更新體驗者生日
      }
      socket.broadcast.emit("UpData", serverClient);
      console.log("www Database SaveBase: "+" catchIndex:"+catchIndex);
      console.log(saveBase);
      console.log("www Database emit server: "+" catchIndex:"+catchIndex);
      console.log(serverClient);
    });
  
    socket.on("Restart",function (Restart) {
      socket.broadcast.emit("RestartClient",Restart);
      saveBase = RestartBase;
      console.log("www Database RestartBase: ");
      console.log(saveBase);
    });
//////////////////////////////////////////////////伺服端問題庫建置////////////////////////////
  socket.on("getQuest",function (questRoleIndex,questIndex) {//questRoleIndex決定角色，收到來自Client端的角色確認的數值，並將其當作選題索引，questRoleIndex: 控制角色種類,questIndex 控制該角色種類下第幾個題目
    if(questRoleIndex === 0)//抽角色
    {
      // console.log(questRoleIndex);
      // console.log(questIndex);
      setQuestBase.questRoleIndex[catchIndex] = choiceRole();
    }
      setQuestBase.questIndex[catchIndex] = questIndex;//將進行到的題目存在跟IP索引一樣的位置
    if(setQuestBase.questRoleIndex[catchIndex] === 1)//設定對應角色的題目，0: 未定，1:警察，2:律師, 3朋友, 4:家人:
    {
      setQuestBase.questRole = "警察";//題庫種類、角色種類名稱
      if (questIndex === 0)//警察 第一題
      {
        setQuestBase.questBase[0] = "PQ:1";//題目，請在這更改正式的題目內容，P 警察代稱測試時使用，可覆寫
      }
      else if(questIndex === 1)//警察 第二題
      {
        setQuestBase.questBase[1] = "PQ2:";
      }
      else if(questIndex === 2)//警察 第三題
      {
        setQuestBase.questBase[2] = "PQ3:";
      }
    }
    else if (setQuestBase.questRoleIndex[catchIndex] === 2)
    {
      setQuestBase.questRole = "律師";//題庫種類、角色種類名稱
      if (questIndex === 0)//律師 第一題
      {
        setQuestBase.questBase[0] = "LQ:1";//題目，請在這更改正式的題目內容，L 律師代稱測試時使用，可覆寫
      }
      else if(questIndex === 1)//律師 第二題
      {
        setQuestBase.questBase[1] = "LQ2:";
      }
      else if(questIndex === 2)//律師 第三題
      {
        setQuestBase.questBase[2] = "LQ3:";
      }
    }
    else  if (setQuestBase.questRoleIndex[catchIndex] === 3)
    {
      setQuestBase.questRole = "朋友";//題庫種類、角色種類名稱
      if (questIndex === 0)//朋友 第一題
      {
        setQuestBase.questBase[0] = "FQ:1";//題目，請在這更改正式的題目內容，F 朋友代稱測試時使用，可覆寫
      }
      else if(questIndex === 1)//朋友 第二題
      {
        setQuestBase.questBase[1] = "FQ2:";
      }
      else if(questIndex === 2)//朋友 第三題
      {
        setQuestBase.questBase[2] = "FQ3:";
      }
    }
    else if (setQuestBase.questRoleIndex[catchIndex] === 4)
    {
      setQuestBase.questRole = "家人";//題庫種類、角色種類名稱
      if (questIndex === 0)//家人 第一題
      {
        setQuestBase.questBase[0] = "RQ:1";//題目，請在這更改正式的題目內容，R 家人代稱測試時使用，可覆寫
      }
      else if(questIndex === 1)//家人 第二題
      {
        setQuestBase.questBase[1] = "RQ2:";
      }
      else if(questIndex === 2)//家人 第三題
      {
        setQuestBase.questBase[2] = "RQ3:";
      }
    }
    function choiceRole () {
      let role = Math.floor(Math.random()*5)+1;
      //Math.random取樹為0.0000~0.999，Math.floor為無條件捨去到比自身小的最大整數，這裡的範圍直為1~4
      return role;
    }
  });
  socket.emit("setQuest",setQuestBase);//送回呼叫題庫的Client端(單一)
});





/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);

/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

io.listen(server);// 開啟 Socket.IO 的 listener

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== 'listen') {
    throw error;
  }

  var bind = typeof port === 'string'
    ? 'Pipe ' + port
    : 'Port ' + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case 'EACCES':
      console.error(bind + ' requires elevated privileges');
      process.exit(1);
      break;
    case 'EADDRINUSE':
      console.error(bind + ' is already in use');
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  debug('Listening on ' + bind);
}
